---
title: "data_analysis_v2"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_packages}
# # Ensure that pacman is installed for package management and loading.
# if (!require("pacman")) install.packages("pacman")
# # for data reading wrangling and visualization
pacman::p_load(tidyverse) 
# for working directories
pacman::p_load(here) 
# # for cross tabulation and data cleaning
# pacman::p_load(janitor) 
# for working with strings
pacman::p_load(glue) 
# For randomized inference, also loads randomizr and estimatr 
pacman::p_load(ri2) 
# for marginal effects from lineal regressions
pacman::p_load(margins)
# Tests for linear regression models
pacman::p_load(lmtest)
pacman::p_load(car)
# Tables
pacman::p_load(kableExtra)
# for updated ggplot2 theme
pacman::p_load(hrbrthemes)
# for updated ggplot2 colorblind-friendly scheme
pacman::p_load(ggthemes)
# theme_set(hrbrthemes::theme_ipsum())
pacman::p_load(reshape2)
# for plotting of covariate balance
pacman::p_load(cobalt)
# for matching only
# pacman::p_load(MatchIt)
```

```{r read_data}
#download the data from GitHub
data <-'https://raw.githubusercontent.com/gsbDBI/ALP301-spr21-project3/main/rla_clean_5_12.csv'
df <- read.csv(data, strip.white = TRUE)
rm(data) #remove data csv file
```

```{r treatment table}
#table() creates a contingency table of counts of observations at each combination of treat_pseudo and treat_real
with(df, table(treatment_group, useNA = 'ifany')) %>%  # "ifany" includes the NA values in the table
  knitr::kable() %>%                                            #kabel(x, format) generates tables 
  # add in a header to label what we're cross-tabulating with
  add_header_above(c('treat_group' = 2)) %>% #add_header_above(x, col_name=col_span)
  kableExtra::kable_styling(bootstrap_options = "striped") #additional styling options

```

```{r attention check}
#see who is in the top 2.5% of least amount of time spent on the survey 
quantile(df$duration_sec, c(0.025, 0.95, .975)) 
# we see the duration is 88 seconds for the top 2.5% and 97.5% (those who spent the least amount)

# make a density plot of the distribution of total time spent on the survey between 
df %>%
  filter( duration_sec < 1050, duration_sec > 88 ) %>%
  ggplot( aes(x=duration_sec)) +
    geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)

```

Another way of checking for balance is to run a multivariate regression of our treatment assignment variable on covariates. With this method, instead of a t-test, we use an F-test for the hypothesis that all coefficients (non-strata) are equal to zero. If a coefficient on a covariate is not close to zero, that would mean that assignment was not balanced on that covariate.

```{r cov_redefine}

df$genderFemale <- ifelse(df$gender == "Female" | df$gender == "Transgender Female", 1, 0)

df$parentYes <- ifelse(df$parent == "Yes", 1, 0)

df$hispanic <- ifelse(grepl("Latino or Hispanic", df$race), 1, 0)

df$edu_4college <- ifelse(df$edu == "edu4-year college degree", 1, 0)
df$edu_hs <- ifelse(df$edu == "High school graduate (high school diploma or equivalent including GED)", 1, 0)

```


```{r balance_plots}

love.plot(treatment_group_num ~ birthyear + genderFemale + parentYes + state + income + hispanic + edu_4college + edu_hs + party,
                 data = df, binary = "std", thresholds = c(m = .1)) # threshold determines the dotted lines on the graph


```
Interpretation: treatment-covariate correlations is very low.


```{r lm_ftest_balance}
# regression of covariates on treatment assignment variable
balance_lm <- lm(treatment_group_num ~ birthyear + genderFemale + parentYes + state + income + hispanic + edu_4college + edu_hs + party, data = df) # factor(region) encodes the string variable as a factor for analysis

<<<<<<< HEAD
# Test whether all coefficients from the balancce_lm regression are equal to zero
# using heteroskedasticity-robust standard errors, denoted by hc2
# car::linearHypothesis(balance_lm, c("birthyear = 0", "gender = 0", "parent = 0",
#                                     "state = 0", "trust_federal = 0",
#                                     "trust_state = 0", "accuracy_2016 = 0", "accuracy_2020 = 0", "income = 0", "race = 0", "edu = 0", "libcon = 0", "party = 0"),
#                       test = "F", white.adjust = "hc2", singular.ok = TRUE)
=======
summary(balance_lm)
>>>>>>> 0116d379b3d77d97fbc078b646ac97314c6d132a
```

None of the coefficients is significant, meaning that there is no significantly different pre-experiment covariates that determine treatment status.

```{r dem vs repub trust}
# of those who identify as democrats how trust 2016 and 2020 
dems <- df %>% 
  filter(party == "Democrat")

repubs <- df %>% 
  filter(party == "Republican")

with(repubs, table(accuracy_2016, useNA = 'ifany')) %>%  # "ifany" includes the NA values in the table
  knitr::kable() %>%                                            #kabel(x, format) generates tables 
  # add in a header to label what we're cross-tabulating with
  add_header_above(c('2016 accuracy' = 2)) %>% #add_header_above(x, col_name=col_span)
  kableExtra::kable_styling(bootstrap_options = "striped") #additional styling options

with(repubs, table(accuracy_2020, useNA = 'ifany')) %>%  # "ifany" includes the NA values in the table
  knitr::kable() %>%                                            #kabel(x, format) generates tables 
  # add in a header to label what we're cross-tabulating with
  add_header_above(c('2020 accuracy' = 2)) %>% #add_header_above(x, col_name=col_span)
  kableExtra::kable_styling(bootstrap_options = "striped") #additional styling options


```

```{r naive regression, echo=FALSE, message=TRUE, warning=FALSE, results='asis'}
# run the regression for state confidence level 
reg1 <- lm(dv_post_state_conf ~ dummy_treat + dv_pre_state_conf, data = df)

# run the regression for national confidence level
reg2 <- lm(dv_post_national_conf ~ dummy_treat + dv_pre_national_conf, data = df)

#reg3 <- lm(dv_post_state_conf ~ factor(treatment_group) + dv_pre_state_conf + factor(gender), data = df)

library(stargazer)
stargazer(reg1, reg2, title = "Basic Regression Results Control vs. Treated")

```

```{r compare_age_dist}
df %>% 
  ggplot(aes(x = birthyear, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position

```

```{r compare_gender_dist}
df %>% 
  ggplot(aes(x = gender, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position

```

```{r compare trust in government}
# plot trust in federal government
df %>% 
  ggplot(aes(x = trust_federal, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position

# trust in state government
df %>% 
  ggplot(aes(x = trust_state, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position
```

```{r Zstats}
# means under each condition
# ybars <- aggregate(yobs, by = list(w), mean)$x # aggregate(x, by=list, FUN) applied function to x by group. In this case, we are taking the means by treatment arm
# sigma <- sqrt(sum((yobs - ybars[w])^2) / (N - K)) # calculation of standard deviation
# 
# # difference in means estimates
# taus <- ybars[-1] - ybars[1] # subtracting the control outcome from each of the three treatment outcomes
# 
# # Z-stat
# Z_stat <- taus / (sigma * sqrt(2 * K / N)) # calculation of Z stat according to formula above
# Z_stat
```

