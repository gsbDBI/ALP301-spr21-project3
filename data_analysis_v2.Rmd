---
title: "data_analysis_v2"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_packages}
# # Ensure that pacman is installed for package management and loading.
# if (!require("pacman")) install.packages("pacman")
# # for data reading wrangling and visualization
pacman::p_load(tidyverse) 
# for working directories
pacman::p_load(here) 
# # for cross tabulation and data cleaning
# pacman::p_load(janitor) 
# for working with strings
pacman::p_load(glue) 
# For randomized inference, also loads randomizr and estimatr 
pacman::p_load(ri2) 
# for marginal effects from lineal regressions
pacman::p_load(margins)
# Tests for linear regression models
pacman::p_load(lmtest)
pacman::p_load(car)
# Tables
pacman::p_load(kableExtra)
# for updated ggplot2 theme
pacman::p_load(hrbrthemes)
# for updated ggplot2 colorblind-friendly scheme
pacman::p_load(ggthemes)
# theme_set(hrbrthemes::theme_ipsum())
pacman::p_load(reshape2)
# for plotting of covariate balance
pacman::p_load(cobalt)
# for matching only
pacman::p_load(MatchIt)
library(stargazer)
library(usmap) 
library(ggplot2)  
library(maps)  
#install.packages("mapproj") 
library(mapproj)
#install.packages("viridis")
library(viridis)
library(dplyr)
library(ggthemes) 

```

```{r read_data}
#download the data from GitHub
data <-'https://raw.githubusercontent.com/gsbDBI/ALP301-spr21-project3/main/rla_clean_5_12.csv'
df <- read.csv(data, strip.white = TRUE)
rm(data) #remove data csv file
```

```{r treatment table}
#table() creates a contingency table of counts of observations at each combination of treat_pseudo and treat_real
with(df, table(treatment_group, useNA = 'ifany')) %>%  # "ifany" includes the NA values in the table
  knitr::kable() %>%                                            #kabel(x, format) generates tables 
  # add in a header to label what we're cross-tabulating with
  add_header_above(c('treat_group' = 2)) %>% #add_header_above(x, col_name=col_span)
  kableExtra::kable_styling(bootstrap_options = "striped") #additional styling options

```

```{r attention check}
#see who is in the top 2.5% of least amount of time spent on the survey 
quantile(df$duration_sec, c(0.025, 0.95, .975)) 
# we see the duration is 88 seconds for the top 2.5% and 97.5% (those who spent the least amount)

# make a density plot of the distribution of total time spent on the survey between 
df %>%
  filter( duration_sec < 1050, duration_sec > 88 ) %>%
  ggplot( aes(x=duration_sec)) +
    geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)
```

```{r graph of income}
# make bar graph of income
p2 <- ggplot(data = subset(df, income != ""), aes(income)) + 
  geom_bar(binwidth=3, fill="#1c3ca8cf", color="#e9ecef", alpha=0.9) +
  ggtitle("Income of respondents") +
theme(
  plot.background = element_rect(fill = "white"),
  panel.background = element_rect(fill = "white"),
  axis.line.x = element_line(color = "grey")
  ) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), plot.title = element_text(size=10))

#ggsave("income.png", plot = p2)

p3 <- ggplot(data = df, aes(treatment_group)) +
  geom_bar(binwidth=3, fill="#1c3ca8cf", color="#e9ecef", alpha=0.9) +
  ggtitle("Treatment groups of respondents") +
theme(
  plot.background = element_rect(fill = "white"),
  panel.background = element_rect(fill = "white"),
  axis.line.x = element_line(color = "grey")
  ) +
  xlab("Treatment Group") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), plot.title = element_text(size=10))

#ggsave("treatment_group.png", plot = p3)
```

```{r cov_redefine}
#included in cleaning script
# df$gender_female <- ifelse(df$gender == "Female" | df$gender == "Transgender Female", 1, 0)
# 
# df$parent_yes <- ifelse(df$parent == "Yes", 1, 0)
# 
# df$hispanic <- ifelse(grepl("Latino or Hispanic", df$race), 1, 0)
# 
# df$edu_4college <- ifelse(df$edu == "edu4-year college degree", 1, 0)
# df$edu_hs <- ifelse(df$edu == "High school graduate (high school diploma or equivalent including GED)", 1, 0)

```

```{r map of respondents}
# load US state map data
us_states <- map_data("state")  
head(us_states)  

# aggregate number of respondents per state from your survey data
bystate <- df %>% 
  group_by(state) %>% 
  dplyr::summarise(
    numbperstate = n()
  )

# merge RLA data w/maps data

bystate$state <- tolower(bystate$state)

# fix errors
bystate[bystate$state=="new hampshir",]$state <- "new hampshire"
bystate[bystate$state=="minnesotta",]$state <- "minnesota"
bystate[bystate$state=="west virgina",]$state <- "west virginia"

us_states_df <- us_states %>% 
  left_join(bystate, by = c("region" = "state"))

p <- ggplot(data = us_states_df,
             mapping = aes(x = long, y = lat,
                           group = group, fill = numbperstate))+
  geom_polygon(color = "gray90", size = 0.1) +
  coord_map(projection = "albers", lat0 = 39, lat1 = 45) +
  scale_fill_continuous(type = "viridis", name = "Number of respondents \n per state") +
  theme_map() +
  theme(legend.position="bottom",
        axis.line=element_blank(),
        axis.text=element_blank(),
        axis.ticks=element_blank(),
        axis.title=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid=element_blank(),
        text = element_text(size=14))

#ggsave("map.png", plot = p)

```


```{r balance_plots}

love.plot(treatment_group_num ~ birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + dv_pre_state_conf + dv_pre_national_conf + party,
                 data = df, 
          binary = "std", 
          limits = c(-.5, .5),
          thresholds = c(m = .1)) # threshold determines the dotted lines on the graph

m.out <- matchit(dummy_treat ~ birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + dv_pre_state_conf + dv_pre_national_conf + party,
                 data = df, 
                method = "nearest", replace = TRUE) # perform matching
# plot covariate balance with and without matching
love.plot(m.out, binary = "std", thresholds = c(m = .1))
```
Interpretation: treatment-covariate correlations is very low.

```{r region_probs}
# Check whether treatment assignment probabilities vary by region
# lm_robust performs linear regression with robust standard errors
# including a -1 in the regression model drops the intercept
# ~ indicates the regression equation: dependent variable ~ independent variables
estimatr::lm_robust(dummy_treat ~ state - 1, data = df) 
```

Another way of checking for balance is to run a multivariate regression of our treatment assignment variable on covariates. With this method, instead of a t-test, we use an F-test for the hypothesis that all coefficients (non-strata) are equal to zero. If a coefficient on a covariate is not close to zero, that would mean that assignment was not balanced on that covariate.

```{r lm_ftest_balance}
# regression of covariates on treatment assignment variable
balance_lm <- lm(treatment_group_num ~ birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + party + birthyear + dv_pre_state_conf + dv_pre_national_conf, data = df) # factor(region) encodes the string variable as a factor for analysis


# Test whether all coefficients from the balancce_lm regression are equal to zero
# using heteroskedasticity-robust standard errors, denoted by hc2
car::linearHypothesis(balance_lm, c("gender_female = 0", "parent_yes = 0", "hispanic = 0", "edu_hs = 0", "dv_pre_state_conf = 0", "dv_pre_national_conf = 0"),
  test = "F", white.adjust = "hc2", singular.ok = TRUE)

summary(balance_lm)
```

None of the coefficients is significant, meaning that there is no significantly different pre-experiment covariates that determine treatment status.

```{r balance_table}
# Define a function to generate a balance check table using two-sample t-test 
# Parameters: "cov_list" includes covariates, "treat" indicates the treatment, "alpha" is the significance level
t_table <- function(data, cov_list, treat,
                    alpha = 0.05) {
  # for each covariate in cov_list, apply a function to conduct the t-test
  out <- lapply(cov_list, function(x) {
      tres <- t.test(data[[x]] ~ data[[treat]]) # t-test result between control and treatment groups' covariate x
    # capture the group means for both control and treatment, and the p-value
    c(mean_control = as.numeric(tres$estimate[1]), mean_treat = as.numeric(tres$estimate[2]), p_value = tres$p.value)    
  })
  
  # save results by binding the results for all above covariates in cov_list by row (rbind)
  out <- as.data.frame(do.call(rbind, out))
  # combine covaraite names and results by column (cbind)
  out <- cbind(covariate = cov_list, out)
  # get ride of non-important strings in the names
  names(out) <- gsub("[^0-9A-Za-z_]", "", names(out)) # gsub(pattern, replacement, x) replaces pattern in x with replacement
  
  # code presentation of p-value according to whether they are below a threshold, for e.g., 0.001
  out$p_value <- ifelse(out$p_value < 0.001,
    "<0.001",
    round(out$p_value, 3) # rounding of p values to 3 decimal places
  )
  return(out)
}

# Apply above t-t_table function to our dataset and selected covariates
balance_table <- t_table(
  data = df,
  c("gender_female", "parent_yes", "hispanic", "edu_hs", "trust_federal", "trust_state"),
  "dummy_treat"
)

# output the balance table
balance_table %>% 
  knitr::kable() %>%
  kableExtra::kable_styling(bootstrap_options = "striped")
```

We see that we reject the null hypothesis of equal means for all of the covariates, as all the P-values are > 0.01.

```{r region_balance}
# balance table for Democrats
balance_dems <- t_table(
  data = subset(df, party=="Democrat"), # subsetting data to those with "party" equal to "Democrat"
  c("gender_female", "parent_yes", "hispanic", "edu_hs", "trust_federal", "trust_state"),
  "dummy_treat"
)

# balance table for Republicans
balance_repubs <- t_table(
  data = subset(df, party=="Republican"), # subsetting data to those with "party" equal to "Republican"
  c("gender_female", "parent_yes", "hispanic", "edu_hs", "trust_federal", "trust_state"),
  "dummy_treat"
)

balance_indpt_other <- t_table(
  data = subset(df, party=="Independent" | party == "Other Party"), # subsetting data to those with "party" equal to "Republican"
  c("gender_female", "parent_yes", "hispanic", "edu_hs", "trust_federal", "trust_state"),
  "dummy_treat"
)

# combine the 4 t-tables, excluding first column of covariate names for the latter 3, so that only one covariate name column is there
balance_party = cbind(balance_dems, balance_repubs %>% select(2:4), balance_indpt_other %>% select(2:4))

# Format: adding in headers
x <- knitr::kable(balance_party, digits = 2) %>% kable_styling()
# add in a header to label what we're cross-tabulating with
add_header_above(x, c('', 'Democrats'=3, 'Republicans'=3, 'Other and Independent'=3))


```

```{r dem vs repub trust}
# of those who identify as democrats how trust 2016 and 2020 

# p4 <- ggplot(data = df, aes(accuracy_2016)) +
#   geom_bar(binwidth=3, fill="#1c3ca8cf", color="#e9ecef", alpha=0.9) +
#   ggtitle("Treatment groups of respondents") +
# theme(
#   plot.background = element_rect(fill = "white"),
#   panel.background = element_rect(fill = "white"),
#   axis.line.x = element_line(color = "grey")
#   ) +
#   xlab("2016 accuracy") +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), plot.title = element_text(size=10))

```

```{r basic regression}
# run the regression for state confidence level 
reg1 <- lm(dv_post_state_conf ~ dummy_treat + dv_pre_state_conf, data = df)

# run the regression for national confidence level
reg2 <- lm(dv_post_national_conf ~ dummy_treat + dv_pre_national_conf, data = df)

# run the regression with controls for state level
reg3 <- lm(dv_post_state_conf ~ dummy_treat + dv_pre_state_conf + birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + party, data = df)

# run the regression with controls for national level
reg4 <- lm(dv_post_national_conf ~ dummy_treat + dv_pre_national_conf + birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + party, data = df)

# run the regression with treatment groups
df$treatment_group <- relevel(factor(df$treatment_group), ref = "Control")

#state level with treatment groups
reg5 <- lm(dv_post_state_conf ~ treatment_group + dv_pre_state_conf + birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + party, data = df)

# national with treatment groups
reg6 <- lm(dv_post_national_conf ~ treatment_group + dv_pre_national_conf + birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + party, data = df)
```

```{r reg table, echo=FALSE, message=TRUE, warning=FALSE, results='asis'}
stargazer(reg3, reg4, 
          omit = "state", "income",
          column.labels=c("state","national", "state with controls", "national with controls"),
          title = "Basic Regression Results for Treatment Effect")

```

```{r coefficient plot control vs treated}
library(jtools)
plot_coefs(
  reg1, reg2, reg3, reg4, 
  coefs = c("Treatment Effect \n vs. Control \n (95% C.I.)" = "dummy_treat"),
  ci_level = 0.95,
  model.names = c("State", "National", "State w/ controls", "National w/ controls"),
  scale = TRUE)
```

```{r coefficient plot of treatment effects}
plot_coefs(
  reg5, reg6, 
  coefs = c("Bipartisan Auditors" = "treatment_groupBipartisan", "Handcount" = "treatment_groupHandcount", "Local Officials" = "treatment_groupLocal", "Loser" = "treatment_groupLoser", "RLA percentage" = "treatment_groupRL_percentage", "Soup \n 95% C.I." = "treatment_groupSoup"),
  ci_level = 0.95,
  model.names = c("State", "National"),
  x.label = "Estimate",
  scale = TRUE)

```

```{r compare_age_dist}
df %>% 
  ggplot(aes(x = birthyear, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position

```

```{r compare_gender_dist}
df %>% 
  ggplot(aes(x = gender, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position

```

```{r compare trust in government}
# plot trust in federal government
df %>% 
  ggplot(aes(x = trust_federal, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position

# trust in state government
df %>% 
  ggplot(aes(x = trust_state, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position
```

```{r difference_in_means_simple}
# simple difference in means for those treated with a message
with(df, mean(dv_post_state_conf[dummy_treat == 1]) - mean(dv_post_state_conf[dummy_treat == 0])) #with(data, expr, …) evaluates the expr on the data

with(df, mean(dv_post_national_conf[dummy_treat == 1]) - mean(dv_post_national_conf[dummy_treat == 0])) #with(data, expr, …) evaluates the expr on the data
```

We use this `difference_in_means` function because it allows us to subset data, and conveniently provides the standard error and other statistics for the estimate. 

```{r difference_in_means}
# Use the estimatr package for difference in means estimates
estimatr::difference_in_means(dv_post_state_conf ~ dummy_treat, data = df) 
# difference_in_means(y ~ x, data) computes mean(y when x==1) - mean(y when x==0) in data, along with standard errors and p-values from two-sided t-tests

estimatr::difference_in_means(dv_post_national_conf ~ dummy_treat, data = df) 

```

#difference in means by gender

```{r difference_in_meansIA_A}
# difference in means for Iowa non-competitive stratum
estimatr::difference_in_means(dv_post_state_conf ~ treatment_group, data = df, subset = region == "Iowa A")
```

#use lm robust for heterosked errors

```{r lm_robust}
# Use the lm_robust function from the estimatr package
estimatr::lm_robust(vote02 ~ treat_real, data = mobilize_listed_df)
```

```{r Zstats}
# means under each condition
# ybars <- aggregate(yobs, by = list(w), mean)$x # aggregate(x, by=list, FUN) applied function to x by group. In this case, we are taking the means by treatment arm
# sigma <- sqrt(sum((yobs - ybars[w])^2) / (N - K)) # calculation of standard deviation
# 
# # difference in means estimates
# taus <- ybars[-1] - ybars[1] # subtracting the control outcome from each of the three treatment outcomes
# 
# # Z-stat
# Z_stat <- taus / (sigma * sqrt(2 * K / N)) # calculation of Z stat according to formula above
# Z_stat
```

