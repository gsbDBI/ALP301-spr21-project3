---
title: "data_analysis_v2"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_packages}
# # Ensure that pacman is installed for package management and loading.
# if (!require("pacman")) install.packages("pacman")
# # for data reading wrangling and visualization
pacman::p_load(tidyverse) 
# for working directories
pacman::p_load(here) 
# # for cross tabulation and data cleaning
# pacman::p_load(janitor) 
# for working with strings
pacman::p_load(glue) 
# For randomized inference, also loads randomizr and estimatr 
pacman::p_load(ri2) 
# for marginal effects from lineal regressions
pacman::p_load(margins)
# Tests for linear regression models
pacman::p_load(lmtest)
pacman::p_load(car)
# Tables
pacman::p_load(kableExtra)
# for updated ggplot2 theme
pacman::p_load(hrbrthemes)
# for updated ggplot2 colorblind-friendly scheme
pacman::p_load(ggthemes)
# theme_set(hrbrthemes::theme_ipsum())
pacman::p_load(reshape2)
# for plotting of covariate balance
pacman::p_load(cobalt)
# for matching only
# pacman::p_load(MatchIt)
library(stargazer)
```

```{r read_data}
#download the data from GitHub
data <-'https://raw.githubusercontent.com/gsbDBI/ALP301-spr21-project3/main/rla_clean_5_12.csv'
df <- read.csv(data, strip.white = TRUE)
rm(data) #remove data csv file
```

```{r treatment table}
#table() creates a contingency table of counts of observations at each combination of treat_pseudo and treat_real
with(df, table(treatment_group, useNA = 'ifany')) %>%  # "ifany" includes the NA values in the table
  knitr::kable() %>%                                            #kabel(x, format) generates tables 
  # add in a header to label what we're cross-tabulating with
  add_header_above(c('treat_group' = 2)) %>% #add_header_above(x, col_name=col_span)
  kableExtra::kable_styling(bootstrap_options = "striped") #additional styling options

```

```{r attention check}
#see who is in the top 2.5% of least amount of time spent on the survey 
quantile(df$duration_sec, c(0.025, 0.95, .975)) 
# we see the duration is 88 seconds for the top 2.5% and 97.5% (those who spent the least amount)

# make a density plot of the distribution of total time spent on the survey between 
df %>%
  filter( duration_sec < 1050, duration_sec > 88 ) %>%
  ggplot( aes(x=duration_sec)) +
    geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)

# make bar graph of income
p2 <- ggplot(df, aes(income)) + 
  geom_bar(binwidth=3, fill="#69b3a2", color="#e9ecef", alpha=0.9) +
  ggtitle("Income of respondents") +
theme(
  plot.background = element_rect(fill = "white"),
  panel.background = element_rect(fill = "white"),
  axis.line.x = element_line(color = "grey")
  ) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), plot.title = element_text(size=10))


#ggsave("income.png", plot = p2)

```

Another way of checking for balance is to run a multivariate regression of our treatment assignment variable on covariates. With this method, instead of a t-test, we use an F-test for the hypothesis that all coefficients (non-strata) are equal to zero. If a coefficient on a covariate is not close to zero, that would mean that assignment was not balanced on that covariate.

```{r cov_redefine}

df$gender_female <- ifelse(df$gender == "Female" | df$gender == "Transgender Female", 1, 0)

df$parent_yes <- ifelse(df$parent == "Yes", 1, 0)

df$hispanic <- ifelse(grepl("Latino or Hispanic", df$race), 1, 0)

df$edu_4college <- ifelse(df$edu == "edu4-year college degree", 1, 0)
df$edu_hs <- ifelse(df$edu == "High school graduate (high school diploma or equivalent including GED)", 1, 0)

```

```{r map of respondents}
library(usmap) 
library(ggplot2)  
library(maps)  
#install.packages("mapproj") 
library(mapproj)
#install.packages("viridis")
library(viridis)
library(dplyr)
library(ggthemes) 

# load US state map data
us_states <- map_data("state")  
head(us_states)  

# aggregate number of respondents per state from your survey data
bystate <- df %>% 
  group_by(state) %>% 
  dplyr::summarise(
    numbperstate = n()
  )

# merge RLA data w/maps data

bystate$state <- tolower(bystate$state)

# fix errors
bystate[bystate$state=="new hampshir",]$state <- "new hampshire"
bystate[bystate$state=="minnesotta",]$state <- "minnesota"
bystate[bystate$state=="west virgina",]$state <- "west virginia"

us_states_df <- us_states %>% 
  left_join(bystate, by = c("region" = "state"))

p <- ggplot(data = us_states_df,
             mapping = aes(x = long, y = lat,
                           group = group, fill = numbperstate))+
  geom_polygon(color = "gray90", size = 0.1) +
  coord_map(projection = "albers", lat0 = 39, lat1 = 45) +
  scale_fill_continuous(type = "viridis", name = "Number of respondents \n per state") +
  theme_map() +
  theme(legend.position="bottom",
        axis.line=element_blank(),
        axis.text=element_blank(),
        axis.ticks=element_blank(),
        axis.title=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid=element_blank(),
        text = element_text(size=14))

#ggsave("map.png", plot = p)

```


```{r balance_plots}

love.plot(treatment_group_num ~ birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + dv_pre_state_conf + dv_pre_national_conf + party,
                 data = df, 
          binary = "std", 
          limits = c(-.5, .5),
          thresholds = c(m = .1)) # threshold determines the dotted lines on the graph

library(MatchIt)
m.out <- matchit(dummy_treat ~ birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + dv_pre_state_conf + dv_pre_national_conf + party,
                 data = df, 
                method = "nearest", replace = TRUE) # perform matching
# plot covariate balance with and without matching
love.plot(m.out, binary = "std", thresholds = c(m = .1))
```
Interpretation: treatment-covariate correlations is very low.

```{r region_probs}
# Check whether treatment assignment probabilities vary by region
# lm_robust performs linear regression with robust standard errors
# including a -1 in the regression model drops the intercept
# ~ indicates the regression equation: dependent variable ~ independent variables
estimatr::lm_robust(dummy_treat ~ state - 1, data = df) 
```
Similarly, we can check whether demographics vary by region.

```{r region_covariates}
# Similarly, check whether age vary by region by using regression
estimatr::lm_robust(birthyear ~ state - 1, data = df)
```

```{r lm_ftest_balance}
# regression of covariates on treatment assignment variable
balance_lm <- lm(treatment_group_num ~ birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + party + dv_pre_state_conf + dv_pre_national_conf, data = df) # factor(region) encodes the string variable as a factor for analysis


# Test whether all coefficients from the balancce_lm regression are equal to zero
# using heteroskedasticity-robust standard errors, denoted by hc2
car::linearHypothesis(balance_lm, c(
  "birthyear = 0", "gender_female = 0", "parent_yes = 0", "hispanic = 0", "edu_hs = 0", "dv_pre_state_conf = 0", "dv_pre_national_conf = 0"),
  test = "F", white.adjust = "hc2", singular.ok = TRUE)

summary(balance_lm)
```

None of the coefficients is significant, meaning that there is no significantly different pre-experiment covariates that determine treatment status.

```{r dem vs repub trust}
# of those who identify as democrats how trust 2016 and 2020 
dems <- df %>% 
  filter(party == "Democrat")

repubs <- df %>% 
  filter(party == "Republican")

with(repubs, table(accuracy_2016, useNA = 'ifany')) %>%  # "ifany" includes the NA values in the table
  knitr::kable() %>%                                            #kabel(x, format) generates tables 
  # add in a header to label what we're cross-tabulating with
  add_header_above(c('2016 accuracy' = 2)) %>% #add_header_above(x, col_name=col_span)
  kableExtra::kable_styling(bootstrap_options = "striped") #additional styling options

with(repubs, table(accuracy_2020, useNA = 'ifany')) %>%  # "ifany" includes the NA values in the table
  knitr::kable() %>%                                            #kabel(x, format) generates tables 
  # add in a header to label what we're cross-tabulating with
  add_header_above(c('2020 accuracy' = 2)) %>% #add_header_above(x, col_name=col_span)
  kableExtra::kable_styling(bootstrap_options = "striped") #additional styling options


```

```{r naive regression}
# run the regression for state confidence level 
reg1 <- lm(dv_post_state_conf ~ dummy_treat + dv_pre_state_conf, data = df)

# run the regression for national confidence level
reg2 <- lm(dv_post_national_conf ~ dummy_treat + dv_pre_national_conf, data = df)

# run the regression with controls for state level
reg3 <- lm(dv_post_state_conf ~ dummy_treat + dv_pre_state_conf + birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + party, data = df)

# run the regression with controls for national level
reg4 <- lm(dv_post_national_conf ~ dummy_treat + dv_pre_national_conf + birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + party, data = df)

# run the regression with treatment groups
df$treatment_group <- relevel(factor(df$treatment_group), ref = "Control")

#state level with treatment groups
reg5 <- lm(dv_post_state_conf ~ treatment_group + dv_pre_state_conf + birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + party, data = df)

# national with treatment groups
reg6 <- lm(dv_post_national_conf ~ treatment_group + dv_pre_national_conf + birthyear + gender_female + parent_yes + state + income + hispanic + edu_4college + edu_hs + party, data = df)
```

```{r reg table, echo=FALSE, message=TRUE, warning=FALSE, results='asis'}
stargazer(reg3, reg4, 
          omit = "state", "income",
          column.labels=c("state","national", "state with controls", "national with controls"),
          title = "Basic Regression Results for Treatment Effect")

```

```{r coefficient plot control vs treated}
library(jtools)
plot_coefs(
  reg1, reg2, reg3, reg4, 
  coefs = c("Treatment Effect \n vs. Control \n (95% C.I.)" = "dummy_treat"),
  ci_level = 0.95,
  model.names = c("State", "National", "State w/ controls", "National w/ controls"),
  scale = TRUE)
```

```{r coefficient plot of treatment effects}
plot_coefs(
  reg5, reg6, 
  coefs = c("Bipartisan Auditors" = "treatment_groupBipartisan", "Handcount" = "treatment_groupHandcount", "Local Officials" = "treatment_groupLocal", "Loser" = "treatment_groupLoser", "RLA percentage" = "treatment_groupRL_percentage", "Soup \n 95% C.I." = "treatment_groupSoup"),
  ci_level = 0.95,
  model.names = c("State", "National"),
  x.label = "Estimate",
  scale = TRUE)

```

```{r compare_age_dist}
df %>% 
  ggplot(aes(x = birthyear, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position

```

```{r compare_gender_dist}
df %>% 
  ggplot(aes(x = gender, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position

```

```{r compare trust in government}
# plot trust in federal government
df %>% 
  ggplot(aes(x = trust_federal, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position

# trust in state government
df %>% 
  ggplot(aes(x = trust_state, # aes(x, y, ...) defines how variables are mapped into the aesthetics of the plot 
            color = treatment_group,
            fill = treatment_group
             )
         ) +
  # Density plot
  geom_density(alpha = 0.3) +    # alpha controls the transparency
  # use a colorblind friendly color palette
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme(legend.position = "top") # legend position
```

```{r difference_in_means_simple}
# simple difference in means for those voted in 2002
with(df, mean(dv_post_state_conf[dummy_treat == 1]) - mean(dv_post_state_conf[dummy_treat == 0])) #with(data, expr, …) evaluates the expr on the data

with(df, mean(dv_post_national_conf[dummy_treat == 1]) - mean(dv_post_national_conf[dummy_treat == 0])) #with(data, expr, …) evaluates the expr on the data
```

```{r difference_in_means}
# Use the estimatr package for difference in means estimates
estimatr::difference_in_means(dv_post_state_conf ~ dummy_treat, data = df) 
# difference_in_means(y ~ x, data) computes mean(y when x==1) - mean(y when x==0) in data, along with standard errors and p-values from two-sided t-tests

estimatr::difference_in_means(dv_post_national_conf ~ dummy_treat, data = df) 

```

```{r Zstats}
# means under each condition
# ybars <- aggregate(yobs, by = list(w), mean)$x # aggregate(x, by=list, FUN) applied function to x by group. In this case, we are taking the means by treatment arm
# sigma <- sqrt(sum((yobs - ybars[w])^2) / (N - K)) # calculation of standard deviation
# 
# # difference in means estimates
# taus <- ybars[-1] - ybars[1] # subtracting the control outcome from each of the three treatment outcomes
# 
# # Z-stat
# Z_stat <- taus / (sigma * sqrt(2 * K / N)) # calculation of Z stat according to formula above
# Z_stat
```

